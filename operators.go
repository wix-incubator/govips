package vips

//golint:ignore

/***
 * NOTE: This file is autogenerated so you shouldn't modify it.
 * See scripts/gen-operators.py
 *
 * Generated at 07:21PM on September 29, 2017
 */

// #cgo pkg-config: vips
// #include "vips/vips.h"
import "C"

// See http://www.vips.ecs.soton.ac.uk/supported/current/doc/html/libvips/func-list.html

// Unsupported: affine: 'VipsArrayDouble'
// Unsupported: arrayjoin: 'VipsArrayImage'
// Unsupported: bandjoin: 'VipsArrayImage'
// Unsupported: bandjoin_const: 'VipsArrayDouble'
// Unsupported: bandrank: 'VipsArrayImage'
// Unsupported: boolean_const: 'VipsArrayDouble'
// Unsupported: draw_circle: 'VipsArrayDouble'
// Unsupported: draw_flood: 'VipsArrayDouble'
// Unsupported: draw_line: 'VipsArrayDouble'
// Unsupported: draw_mask: 'VipsArrayDouble'
// Unsupported: draw_rect: 'VipsArrayDouble'
// Unsupported: getpoint: 'VipsArrayDouble'
// Unsupported: linear: 'VipsArrayDouble'
// Unsupported: math2_const: 'VipsArrayDouble'
// Unsupported: relational_const: 'VipsArrayDouble'
// Unsupported: remainder_const: 'VipsArrayDouble'
// Unsupported: sum: 'VipsArrayImage'

// Abs executes the 'abs' operation.
func Abs(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("abs", options)
	return out, err
}

func (os *OperationStream) Abs(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Abs(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Add executes the 'add' operation.
func Add(left *C.VipsImage, right *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(left))
	defer C.g_object_unref(C.gpointer(right))
	options := NewOptions(opts...).With(
		ImageInput("left", left),
		ImageInput("right", right),
		ImageOutput("out", &out),
	)
	err = vipsCall("add", options)
	return out, err
}

// Analyzeload executes the 'analyzeload' operation.
func Analyzeload(filename string, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		StringInput("filename", filename),
		ImageOutput("out", &out),
	)
	err = vipsCall("analyzeload", options)
	return out, err
}

// Autorot executes the 'autorot' operation.
func Autorot(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("autorot", options)
	return out, err
}

func (os *OperationStream) Autorot(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Autorot(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Avg executes the 'avg' operation.
func Avg(in *C.VipsImage, opts ...OptionFunc) (float64, error) {
	var out float64
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		DoubleOutput("out", &out),
	)
	err = vipsCall("avg", options)
	return out, err
}

// Bandbool executes the 'bandbool' operation.
func Bandbool(in *C.VipsImage, boolean OperationBoolean, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		IntInput("boolean", int(boolean)),
		ImageOutput("out", &out),
	)
	err = vipsCall("bandbool", options)
	return out, err
}

func (os *OperationStream) Bandbool(boolean OperationBoolean, opts ...OptionFunc) (*OperationStream, error) {
	out, err := Bandbool(os.image, boolean, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Bandfold executes the 'bandfold' operation.
func Bandfold(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("bandfold", options)
	return out, err
}

func (os *OperationStream) Bandfold(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Bandfold(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Bandmean executes the 'bandmean' operation.
func Bandmean(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("bandmean", options)
	return out, err
}

func (os *OperationStream) Bandmean(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Bandmean(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Bandunfold executes the 'bandunfold' operation.
func Bandunfold(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("bandunfold", options)
	return out, err
}

func (os *OperationStream) Bandunfold(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Bandunfold(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Black executes the 'black' operation.
func Black(width int, height int, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		IntInput("width", width),
		IntInput("height", height),
		ImageOutput("out", &out),
	)
	err = vipsCall("black", options)
	return out, err
}

// Boolean executes the 'boolean' operation.
func Boolean(left *C.VipsImage, right *C.VipsImage, boolean OperationBoolean, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(left))
	defer C.g_object_unref(C.gpointer(right))
	options := NewOptions(opts...).With(
		ImageInput("left", left),
		ImageInput("right", right),
		IntInput("boolean", int(boolean)),
		ImageOutput("out", &out),
	)
	err = vipsCall("boolean", options)
	return out, err
}

// Buildlut executes the 'buildlut' operation.
func Buildlut(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("buildlut", options)
	return out, err
}

func (os *OperationStream) Buildlut(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Buildlut(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Byteswap executes the 'byteswap' operation.
func Byteswap(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("byteswap", options)
	return out, err
}

func (os *OperationStream) Byteswap(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Byteswap(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Cache executes the 'cache' operation.
func Cache(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("cache", options)
	return out, err
}

func (os *OperationStream) Cache(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Cache(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Cast executes the 'cast' operation.
func Cast(in *C.VipsImage, format BandFormat, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		IntInput("format", int(format)),
		ImageOutput("out", &out),
	)
	err = vipsCall("cast", options)
	return out, err
}

func (os *OperationStream) Cast(format BandFormat, opts ...OptionFunc) (*OperationStream, error) {
	out, err := Cast(os.image, format, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Cmc2Lch executes the 'CMC2LCh' operation.
func Cmc2Lch(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("CMC2LCh", options)
	return out, err
}

func (os *OperationStream) Cmc2Lch(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Cmc2Lch(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Colourspace executes the 'colourspace' operation.
func Colourspace(in *C.VipsImage, space Interpretation, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		IntInput("space", int(space)),
		ImageOutput("out", &out),
	)
	err = vipsCall("colourspace", options)
	return out, err
}

func (os *OperationStream) Colourspace(space Interpretation, opts ...OptionFunc) (*OperationStream, error) {
	out, err := Colourspace(os.image, space, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Compass executes the 'compass' operation.
func Compass(in *C.VipsImage, mask *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	defer C.g_object_unref(C.gpointer(mask))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageInput("mask", mask),
		ImageOutput("out", &out),
	)
	err = vipsCall("compass", options)
	return out, err
}

// Complex executes the 'complex' operation.
func Complex(in *C.VipsImage, cmplx OperationComplex, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		IntInput("cmplx", int(cmplx)),
		ImageOutput("out", &out),
	)
	err = vipsCall("complex", options)
	return out, err
}

func (os *OperationStream) Complex(cmplx OperationComplex, opts ...OptionFunc) (*OperationStream, error) {
	out, err := Complex(os.image, cmplx, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Complex2 executes the 'complex2' operation.
func Complex2(left *C.VipsImage, right *C.VipsImage, cmplx OperationComplex2, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(left))
	defer C.g_object_unref(C.gpointer(right))
	options := NewOptions(opts...).With(
		ImageInput("left", left),
		ImageInput("right", right),
		IntInput("cmplx", int(cmplx)),
		ImageOutput("out", &out),
	)
	err = vipsCall("complex2", options)
	return out, err
}

// Complexform executes the 'complexform' operation.
func Complexform(left *C.VipsImage, right *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(left))
	defer C.g_object_unref(C.gpointer(right))
	options := NewOptions(opts...).With(
		ImageInput("left", left),
		ImageInput("right", right),
		ImageOutput("out", &out),
	)
	err = vipsCall("complexform", options)
	return out, err
}

// Complexget executes the 'complexget' operation.
func Complexget(in *C.VipsImage, get OperationComplexGet, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		IntInput("get", int(get)),
		ImageOutput("out", &out),
	)
	err = vipsCall("complexget", options)
	return out, err
}

func (os *OperationStream) Complexget(get OperationComplexGet, opts ...OptionFunc) (*OperationStream, error) {
	out, err := Complexget(os.image, get, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Conv executes the 'conv' operation.
func Conv(in *C.VipsImage, mask *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	defer C.g_object_unref(C.gpointer(mask))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageInput("mask", mask),
		ImageOutput("out", &out),
	)
	err = vipsCall("conv", options)
	return out, err
}

// Conva executes the 'conva' operation.
func Conva(in *C.VipsImage, mask *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	defer C.g_object_unref(C.gpointer(mask))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageInput("mask", mask),
		ImageOutput("out", &out),
	)
	err = vipsCall("conva", options)
	return out, err
}

// Convasep executes the 'convasep' operation.
func Convasep(in *C.VipsImage, mask *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	defer C.g_object_unref(C.gpointer(mask))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageInput("mask", mask),
		ImageOutput("out", &out),
	)
	err = vipsCall("convasep", options)
	return out, err
}

// Convf executes the 'convf' operation.
func Convf(in *C.VipsImage, mask *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	defer C.g_object_unref(C.gpointer(mask))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageInput("mask", mask),
		ImageOutput("out", &out),
	)
	err = vipsCall("convf", options)
	return out, err
}

// Convi executes the 'convi' operation.
func Convi(in *C.VipsImage, mask *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	defer C.g_object_unref(C.gpointer(mask))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageInput("mask", mask),
		ImageOutput("out", &out),
	)
	err = vipsCall("convi", options)
	return out, err
}

// Convsep executes the 'convsep' operation.
func Convsep(in *C.VipsImage, mask *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	defer C.g_object_unref(C.gpointer(mask))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageInput("mask", mask),
		ImageOutput("out", &out),
	)
	err = vipsCall("convsep", options)
	return out, err
}

// Copy executes the 'copy' operation.
func Copy(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("copy", options)
	return out, err
}

func (os *OperationStream) Copy(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Copy(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Countlines executes the 'countlines' operation.
func Countlines(in *C.VipsImage, direction Direction, opts ...OptionFunc) (float64, error) {
	var nolines float64
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		IntInput("direction", int(direction)),
		DoubleOutput("nolines", &nolines),
	)
	err = vipsCall("countlines", options)
	return nolines, err
}

// Csvload executes the 'csvload' operation.
func Csvload(filename string, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		StringInput("filename", filename),
		ImageOutput("out", &out),
	)
	err = vipsCall("csvload", options)
	return out, err
}

// Csvsave executes the 'csvsave' operation.
func Csvsave(in *C.VipsImage, filename string, opts ...OptionFunc) error {
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		StringInput("filename", filename),
	)
	err = vipsCall("csvsave", options)
	return err
}

// De00 executes the 'dE00' operation.
func De00(left *C.VipsImage, right *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(left))
	defer C.g_object_unref(C.gpointer(right))
	options := NewOptions(opts...).With(
		ImageInput("left", left),
		ImageInput("right", right),
		ImageOutput("out", &out),
	)
	err = vipsCall("dE00", options)
	return out, err
}

// De76 executes the 'dE76' operation.
func De76(left *C.VipsImage, right *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(left))
	defer C.g_object_unref(C.gpointer(right))
	options := NewOptions(opts...).With(
		ImageInput("left", left),
		ImageInput("right", right),
		ImageOutput("out", &out),
	)
	err = vipsCall("dE76", options)
	return out, err
}

// Decmc executes the 'dECMC' operation.
func Decmc(left *C.VipsImage, right *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(left))
	defer C.g_object_unref(C.gpointer(right))
	options := NewOptions(opts...).With(
		ImageInput("left", left),
		ImageInput("right", right),
		ImageOutput("out", &out),
	)
	err = vipsCall("dECMC", options)
	return out, err
}

// Deviate executes the 'deviate' operation.
func Deviate(in *C.VipsImage, opts ...OptionFunc) (float64, error) {
	var out float64
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		DoubleOutput("out", &out),
	)
	err = vipsCall("deviate", options)
	return out, err
}

// Divide executes the 'divide' operation.
func Divide(left *C.VipsImage, right *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(left))
	defer C.g_object_unref(C.gpointer(right))
	options := NewOptions(opts...).With(
		ImageInput("left", left),
		ImageInput("right", right),
		ImageOutput("out", &out),
	)
	err = vipsCall("divide", options)
	return out, err
}

// DrawImage executes the 'draw_image' operation.
func DrawImage(image *C.VipsImage, sub *C.VipsImage, x int, y int, opts ...OptionFunc) error {
	var err error
	defer C.g_object_unref(C.gpointer(image))
	defer C.g_object_unref(C.gpointer(sub))
	options := NewOptions(opts...).With(
		ImageInput("image", image),
		ImageInput("sub", sub),
		IntInput("x", x),
		IntInput("y", y),
	)
	err = vipsCall("draw_image", options)
	return err
}

// DrawSmudge executes the 'draw_smudge' operation.
func DrawSmudge(image *C.VipsImage, left int, top int, width int, height int, opts ...OptionFunc) error {
	var err error
	defer C.g_object_unref(C.gpointer(image))
	options := NewOptions(opts...).With(
		ImageInput("image", image),
		IntInput("left", left),
		IntInput("top", top),
		IntInput("width", width),
		IntInput("height", height),
	)
	err = vipsCall("draw_smudge", options)
	return err
}

// Dzsave executes the 'dzsave' operation.
func Dzsave(in *C.VipsImage, filename string, opts ...OptionFunc) error {
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		StringInput("filename", filename),
	)
	err = vipsCall("dzsave", options)
	return err
}

// DzsaveBuffer executes the 'dzsave_buffer' operation.
func DzsaveBuffer(in *C.VipsImage, opts ...OptionFunc) (*Blob, error) {
	var buffer *Blob
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		BlobOutput("buffer", &buffer),
	)
	err = vipsCall("dzsave_buffer", options)
	return buffer, err
}

// Embed executes the 'embed' operation.
func Embed(in *C.VipsImage, x int, y int, width int, height int, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		IntInput("x", x),
		IntInput("y", y),
		IntInput("width", width),
		IntInput("height", height),
		ImageOutput("out", &out),
	)
	err = vipsCall("embed", options)
	return out, err
}

func (os *OperationStream) Embed(x int, y int, width int, height int, opts ...OptionFunc) (*OperationStream, error) {
	out, err := Embed(os.image, x, y, width, height, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// ExtractArea executes the 'extract_area' operation.
func ExtractArea(input *C.VipsImage, left int, top int, width int, height int, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(input))
	options := NewOptions(opts...).With(
		ImageInput("input", input),
		IntInput("left", left),
		IntInput("top", top),
		IntInput("width", width),
		IntInput("height", height),
		ImageOutput("out", &out),
	)
	err = vipsCall("extract_area", options)
	return out, err
}

func (os *OperationStream) ExtractArea(left int, top int, width int, height int, opts ...OptionFunc) (*OperationStream, error) {
	out, err := ExtractArea(os.image, left, top, width, height, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// ExtractBand executes the 'extract_band' operation.
func ExtractBand(in *C.VipsImage, band int, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		IntInput("band", band),
		ImageOutput("out", &out),
	)
	err = vipsCall("extract_band", options)
	return out, err
}

func (os *OperationStream) ExtractBand(band int, opts ...OptionFunc) (*OperationStream, error) {
	out, err := ExtractBand(os.image, band, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Eye executes the 'eye' operation.
func Eye(width int, height int, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		IntInput("width", width),
		IntInput("height", height),
		ImageOutput("out", &out),
	)
	err = vipsCall("eye", options)
	return out, err
}

// Falsecolour executes the 'falsecolour' operation.
func Falsecolour(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("falsecolour", options)
	return out, err
}

func (os *OperationStream) Falsecolour(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Falsecolour(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Fastcor executes the 'fastcor' operation.
func Fastcor(in *C.VipsImage, ref *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	defer C.g_object_unref(C.gpointer(ref))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageInput("ref", ref),
		ImageOutput("out", &out),
	)
	err = vipsCall("fastcor", options)
	return out, err
}

// Flatten executes the 'flatten' operation.
func Flatten(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("flatten", options)
	return out, err
}

func (os *OperationStream) Flatten(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Flatten(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Flip executes the 'flip' operation.
func Flip(in *C.VipsImage, direction Direction, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		IntInput("direction", int(direction)),
		ImageOutput("out", &out),
	)
	err = vipsCall("flip", options)
	return out, err
}

func (os *OperationStream) Flip(direction Direction, opts ...OptionFunc) (*OperationStream, error) {
	out, err := Flip(os.image, direction, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Float2Rad executes the 'float2rad' operation.
func Float2Rad(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("float2rad", options)
	return out, err
}

func (os *OperationStream) Float2Rad(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Float2Rad(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Fractsurf executes the 'fractsurf' operation.
func Fractsurf(width int, height int, fractalDimension float64, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		IntInput("width", width),
		IntInput("height", height),
		DoubleInput("fractal-dimension", fractalDimension),
		ImageOutput("out", &out),
	)
	err = vipsCall("fractsurf", options)
	return out, err
}

// Freqmult executes the 'freqmult' operation.
func Freqmult(in *C.VipsImage, mask *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	defer C.g_object_unref(C.gpointer(mask))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageInput("mask", mask),
		ImageOutput("out", &out),
	)
	err = vipsCall("freqmult", options)
	return out, err
}

// Fwfft executes the 'fwfft' operation.
func Fwfft(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("fwfft", options)
	return out, err
}

func (os *OperationStream) Fwfft(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Fwfft(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Gamma executes the 'gamma' operation.
func Gamma(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("gamma", options)
	return out, err
}

func (os *OperationStream) Gamma(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Gamma(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Gaussblur executes the 'gaussblur' operation.
func Gaussblur(in *C.VipsImage, sigma float64, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		DoubleInput("sigma", sigma),
		ImageOutput("out", &out),
	)
	err = vipsCall("gaussblur", options)
	return out, err
}

func (os *OperationStream) Gaussblur(sigma float64, opts ...OptionFunc) (*OperationStream, error) {
	out, err := Gaussblur(os.image, sigma, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Gaussmat executes the 'gaussmat' operation.
func Gaussmat(sigma float64, minAmpl float64, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		DoubleInput("sigma", sigma),
		DoubleInput("min-ampl", minAmpl),
		ImageOutput("out", &out),
	)
	err = vipsCall("gaussmat", options)
	return out, err
}

// Gaussnoise executes the 'gaussnoise' operation.
func Gaussnoise(width int, height int, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		IntInput("width", width),
		IntInput("height", height),
		ImageOutput("out", &out),
	)
	err = vipsCall("gaussnoise", options)
	return out, err
}

// Gifload executes the 'gifload' operation.
func Gifload(filename string, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		StringInput("filename", filename),
		ImageOutput("out", &out),
	)
	err = vipsCall("gifload", options)
	return out, err
}

// GifloadBuffer executes the 'gifload_buffer' operation.
func GifloadBuffer(buffer *Blob, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		BlobInput("buffer", buffer),
		ImageOutput("out", &out),
	)
	err = vipsCall("gifload_buffer", options)
	return out, err
}

// Globalbalance executes the 'globalbalance' operation.
func Globalbalance(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("globalbalance", options)
	return out, err
}

func (os *OperationStream) Globalbalance(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Globalbalance(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Grey executes the 'grey' operation.
func Grey(width int, height int, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		IntInput("width", width),
		IntInput("height", height),
		ImageOutput("out", &out),
	)
	err = vipsCall("grey", options)
	return out, err
}

// Grid executes the 'grid' operation.
func Grid(in *C.VipsImage, tileHeight int, across int, down int, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		IntInput("tile-height", tileHeight),
		IntInput("across", across),
		IntInput("down", down),
		ImageOutput("out", &out),
	)
	err = vipsCall("grid", options)
	return out, err
}

func (os *OperationStream) Grid(tileHeight int, across int, down int, opts ...OptionFunc) (*OperationStream, error) {
	out, err := Grid(os.image, tileHeight, across, down, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// HistCum executes the 'hist_cum' operation.
func HistCum(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("hist_cum", options)
	return out, err
}

func (os *OperationStream) HistCum(opts ...OptionFunc) (*OperationStream, error) {
	out, err := HistCum(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// HistEntropy executes the 'hist_entropy' operation.
func HistEntropy(in *C.VipsImage, opts ...OptionFunc) (float64, error) {
	var out float64
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		DoubleOutput("out", &out),
	)
	err = vipsCall("hist_entropy", options)
	return out, err
}

// HistEqual executes the 'hist_equal' operation.
func HistEqual(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("hist_equal", options)
	return out, err
}

func (os *OperationStream) HistEqual(opts ...OptionFunc) (*OperationStream, error) {
	out, err := HistEqual(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// HistFind executes the 'hist_find' operation.
func HistFind(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("hist_find", options)
	return out, err
}

func (os *OperationStream) HistFind(opts ...OptionFunc) (*OperationStream, error) {
	out, err := HistFind(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// HistFindIndexed executes the 'hist_find_indexed' operation.
func HistFindIndexed(in *C.VipsImage, index *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	defer C.g_object_unref(C.gpointer(index))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageInput("index", index),
		ImageOutput("out", &out),
	)
	err = vipsCall("hist_find_indexed", options)
	return out, err
}

// HistFindNdim executes the 'hist_find_ndim' operation.
func HistFindNdim(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("hist_find_ndim", options)
	return out, err
}

func (os *OperationStream) HistFindNdim(opts ...OptionFunc) (*OperationStream, error) {
	out, err := HistFindNdim(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// HistIsmonotonic executes the 'hist_ismonotonic' operation.
func HistIsmonotonic(in *C.VipsImage, opts ...OptionFunc) (bool, error) {
	var monotonic bool
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		BoolOutput("monotonic", &monotonic),
	)
	err = vipsCall("hist_ismonotonic", options)
	return monotonic, err
}

// HistLocal executes the 'hist_local' operation.
func HistLocal(in *C.VipsImage, width int, height int, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		IntInput("width", width),
		IntInput("height", height),
		ImageOutput("out", &out),
	)
	err = vipsCall("hist_local", options)
	return out, err
}

func (os *OperationStream) HistLocal(width int, height int, opts ...OptionFunc) (*OperationStream, error) {
	out, err := HistLocal(os.image, width, height, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// HistMatch executes the 'hist_match' operation.
func HistMatch(in *C.VipsImage, ref *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	defer C.g_object_unref(C.gpointer(ref))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageInput("ref", ref),
		ImageOutput("out", &out),
	)
	err = vipsCall("hist_match", options)
	return out, err
}

// HistNorm executes the 'hist_norm' operation.
func HistNorm(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("hist_norm", options)
	return out, err
}

func (os *OperationStream) HistNorm(opts ...OptionFunc) (*OperationStream, error) {
	out, err := HistNorm(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// HistPlot executes the 'hist_plot' operation.
func HistPlot(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("hist_plot", options)
	return out, err
}

func (os *OperationStream) HistPlot(opts ...OptionFunc) (*OperationStream, error) {
	out, err := HistPlot(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// HoughCircle executes the 'hough_circle' operation.
func HoughCircle(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("hough_circle", options)
	return out, err
}

func (os *OperationStream) HoughCircle(opts ...OptionFunc) (*OperationStream, error) {
	out, err := HoughCircle(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// HoughLine executes the 'hough_line' operation.
func HoughLine(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("hough_line", options)
	return out, err
}

func (os *OperationStream) HoughLine(opts ...OptionFunc) (*OperationStream, error) {
	out, err := HoughLine(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Hsv2Srgb executes the 'HSV2sRGB' operation.
func Hsv2Srgb(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("HSV2sRGB", options)
	return out, err
}

func (os *OperationStream) Hsv2Srgb(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Hsv2Srgb(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// IccExport executes the 'icc_export' operation.
func IccExport(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("icc_export", options)
	return out, err
}

func (os *OperationStream) IccExport(opts ...OptionFunc) (*OperationStream, error) {
	out, err := IccExport(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// IccImport executes the 'icc_import' operation.
func IccImport(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("icc_import", options)
	return out, err
}

func (os *OperationStream) IccImport(opts ...OptionFunc) (*OperationStream, error) {
	out, err := IccImport(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// IccTransform executes the 'icc_transform' operation.
func IccTransform(in *C.VipsImage, outputProfile string, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		StringInput("output-profile", outputProfile),
		ImageOutput("out", &out),
	)
	err = vipsCall("icc_transform", options)
	return out, err
}

func (os *OperationStream) IccTransform(outputProfile string, opts ...OptionFunc) (*OperationStream, error) {
	out, err := IccTransform(os.image, outputProfile, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Identity executes the 'identity' operation.
func Identity(opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(

		ImageOutput("out", &out),
	)
	err = vipsCall("identity", options)
	return out, err
}

// Ifthenelse executes the 'ifthenelse' operation.
func Ifthenelse(cond *C.VipsImage, in1 *C.VipsImage, in2 *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(cond))
	defer C.g_object_unref(C.gpointer(in1))
	defer C.g_object_unref(C.gpointer(in2))
	options := NewOptions(opts...).With(
		ImageInput("cond", cond),
		ImageInput("in1", in1),
		ImageInput("in2", in2),
		ImageOutput("out", &out),
	)
	err = vipsCall("ifthenelse", options)
	return out, err
}

// Insert executes the 'insert' operation.
func Insert(main *C.VipsImage, sub *C.VipsImage, x int, y int, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(main))
	defer C.g_object_unref(C.gpointer(sub))
	options := NewOptions(opts...).With(
		ImageInput("main", main),
		ImageInput("sub", sub),
		IntInput("x", x),
		IntInput("y", y),
		ImageOutput("out", &out),
	)
	err = vipsCall("insert", options)
	return out, err
}

// Invert executes the 'invert' operation.
func Invert(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("invert", options)
	return out, err
}

func (os *OperationStream) Invert(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Invert(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Invertlut executes the 'invertlut' operation.
func Invertlut(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("invertlut", options)
	return out, err
}

func (os *OperationStream) Invertlut(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Invertlut(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Invfft executes the 'invfft' operation.
func Invfft(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("invfft", options)
	return out, err
}

func (os *OperationStream) Invfft(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Invfft(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Join executes the 'join' operation.
func Join(in1 *C.VipsImage, in2 *C.VipsImage, direction Direction, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in1))
	defer C.g_object_unref(C.gpointer(in2))
	options := NewOptions(opts...).With(
		ImageInput("in1", in1),
		ImageInput("in2", in2),
		IntInput("direction", int(direction)),
		ImageOutput("out", &out),
	)
	err = vipsCall("join", options)
	return out, err
}

// Jpegload executes the 'jpegload' operation.
func Jpegload(filename string, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		StringInput("filename", filename),
		ImageOutput("out", &out),
	)
	err = vipsCall("jpegload", options)
	return out, err
}

// JpegloadBuffer executes the 'jpegload_buffer' operation.
func JpegloadBuffer(buffer *Blob, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		BlobInput("buffer", buffer),
		ImageOutput("out", &out),
	)
	err = vipsCall("jpegload_buffer", options)
	return out, err
}

// Jpegsave executes the 'jpegsave' operation.
func Jpegsave(in *C.VipsImage, filename string, opts ...OptionFunc) error {
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		StringInput("filename", filename),
	)
	err = vipsCall("jpegsave", options)
	return err
}

// JpegsaveBuffer executes the 'jpegsave_buffer' operation.
func JpegsaveBuffer(in *C.VipsImage, opts ...OptionFunc) (*Blob, error) {
	var buffer *Blob
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		BlobOutput("buffer", &buffer),
	)
	err = vipsCall("jpegsave_buffer", options)
	return buffer, err
}

// JpegsaveMime executes the 'jpegsave_mime' operation.
func JpegsaveMime(in *C.VipsImage, opts ...OptionFunc) error {
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
	)
	err = vipsCall("jpegsave_mime", options)
	return err
}

// Lab2Labq executes the 'Lab2LabQ' operation.
func Lab2Labq(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("Lab2LabQ", options)
	return out, err
}

func (os *OperationStream) Lab2Labq(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Lab2Labq(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Lab2Labs executes the 'Lab2LabS' operation.
func Lab2Labs(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("Lab2LabS", options)
	return out, err
}

func (os *OperationStream) Lab2Labs(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Lab2Labs(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Lab2Lch executes the 'Lab2LCh' operation.
func Lab2Lch(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("Lab2LCh", options)
	return out, err
}

func (os *OperationStream) Lab2Lch(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Lab2Lch(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Lab2Xyz executes the 'Lab2XYZ' operation.
func Lab2Xyz(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("Lab2XYZ", options)
	return out, err
}

func (os *OperationStream) Lab2Xyz(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Lab2Xyz(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Labelregions executes the 'labelregions' operation.
func Labelregions(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var mask *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("mask", &mask),
	)
	err = vipsCall("labelregions", options)
	return mask, err
}

func (os *OperationStream) Labelregions(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Labelregions(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Labq2Lab executes the 'LabQ2Lab' operation.
func Labq2Lab(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("LabQ2Lab", options)
	return out, err
}

func (os *OperationStream) Labq2Lab(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Labq2Lab(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Labq2Labs executes the 'LabQ2LabS' operation.
func Labq2Labs(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("LabQ2LabS", options)
	return out, err
}

func (os *OperationStream) Labq2Labs(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Labq2Labs(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Labq2Srgb executes the 'LabQ2sRGB' operation.
func Labq2Srgb(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("LabQ2sRGB", options)
	return out, err
}

func (os *OperationStream) Labq2Srgb(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Labq2Srgb(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Labs2Lab executes the 'LabS2Lab' operation.
func Labs2Lab(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("LabS2Lab", options)
	return out, err
}

func (os *OperationStream) Labs2Lab(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Labs2Lab(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Labs2Labq executes the 'LabS2LabQ' operation.
func Labs2Labq(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("LabS2LabQ", options)
	return out, err
}

func (os *OperationStream) Labs2Labq(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Labs2Labq(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Lch2Cmc executes the 'LCh2CMC' operation.
func Lch2Cmc(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("LCh2CMC", options)
	return out, err
}

func (os *OperationStream) Lch2Cmc(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Lch2Cmc(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Lch2Lab executes the 'LCh2Lab' operation.
func Lch2Lab(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("LCh2Lab", options)
	return out, err
}

func (os *OperationStream) Lch2Lab(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Lch2Lab(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Linecache executes the 'linecache' operation.
func Linecache(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("linecache", options)
	return out, err
}

func (os *OperationStream) Linecache(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Linecache(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Logmat executes the 'logmat' operation.
func Logmat(sigma float64, minAmpl float64, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		DoubleInput("sigma", sigma),
		DoubleInput("min-ampl", minAmpl),
		ImageOutput("out", &out),
	)
	err = vipsCall("logmat", options)
	return out, err
}

// Mapim executes the 'mapim' operation.
func Mapim(in *C.VipsImage, index *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	defer C.g_object_unref(C.gpointer(index))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageInput("index", index),
		ImageOutput("out", &out),
	)
	err = vipsCall("mapim", options)
	return out, err
}

// Maplut executes the 'maplut' operation.
func Maplut(in *C.VipsImage, lut *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	defer C.g_object_unref(C.gpointer(lut))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageInput("lut", lut),
		ImageOutput("out", &out),
	)
	err = vipsCall("maplut", options)
	return out, err
}

// MaskButterworth executes the 'mask_butterworth' operation.
func MaskButterworth(width int, height int, order float64, frequencyCutoff float64, amplitudeCutoff float64, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		IntInput("width", width),
		IntInput("height", height),
		DoubleInput("order", order),
		DoubleInput("frequency-cutoff", frequencyCutoff),
		DoubleInput("amplitude-cutoff", amplitudeCutoff),
		ImageOutput("out", &out),
	)
	err = vipsCall("mask_butterworth", options)
	return out, err
}

// MaskButterworthBand executes the 'mask_butterworth_band' operation.
func MaskButterworthBand(width int, height int, order float64, frequencyCutoffx float64, frequencyCutoffy float64, radius float64, amplitudeCutoff float64, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		IntInput("width", width),
		IntInput("height", height),
		DoubleInput("order", order),
		DoubleInput("frequency-cutoff-x", frequencyCutoffx),
		DoubleInput("frequency-cutoff-y", frequencyCutoffy),
		DoubleInput("radius", radius),
		DoubleInput("amplitude-cutoff", amplitudeCutoff),
		ImageOutput("out", &out),
	)
	err = vipsCall("mask_butterworth_band", options)
	return out, err
}

// MaskButterworthRing executes the 'mask_butterworth_ring' operation.
func MaskButterworthRing(width int, height int, order float64, frequencyCutoff float64, amplitudeCutoff float64, ringwidth float64, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		IntInput("width", width),
		IntInput("height", height),
		DoubleInput("order", order),
		DoubleInput("frequency-cutoff", frequencyCutoff),
		DoubleInput("amplitude-cutoff", amplitudeCutoff),
		DoubleInput("ringwidth", ringwidth),
		ImageOutput("out", &out),
	)
	err = vipsCall("mask_butterworth_ring", options)
	return out, err
}

// MaskFractal executes the 'mask_fractal' operation.
func MaskFractal(width int, height int, fractalDimension float64, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		IntInput("width", width),
		IntInput("height", height),
		DoubleInput("fractal-dimension", fractalDimension),
		ImageOutput("out", &out),
	)
	err = vipsCall("mask_fractal", options)
	return out, err
}

// MaskGaussian executes the 'mask_gaussian' operation.
func MaskGaussian(width int, height int, frequencyCutoff float64, amplitudeCutoff float64, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		IntInput("width", width),
		IntInput("height", height),
		DoubleInput("frequency-cutoff", frequencyCutoff),
		DoubleInput("amplitude-cutoff", amplitudeCutoff),
		ImageOutput("out", &out),
	)
	err = vipsCall("mask_gaussian", options)
	return out, err
}

// MaskGaussianBand executes the 'mask_gaussian_band' operation.
func MaskGaussianBand(width int, height int, frequencyCutoffx float64, frequencyCutoffy float64, radius float64, amplitudeCutoff float64, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		IntInput("width", width),
		IntInput("height", height),
		DoubleInput("frequency-cutoff-x", frequencyCutoffx),
		DoubleInput("frequency-cutoff-y", frequencyCutoffy),
		DoubleInput("radius", radius),
		DoubleInput("amplitude-cutoff", amplitudeCutoff),
		ImageOutput("out", &out),
	)
	err = vipsCall("mask_gaussian_band", options)
	return out, err
}

// MaskGaussianRing executes the 'mask_gaussian_ring' operation.
func MaskGaussianRing(width int, height int, frequencyCutoff float64, amplitudeCutoff float64, ringwidth float64, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		IntInput("width", width),
		IntInput("height", height),
		DoubleInput("frequency-cutoff", frequencyCutoff),
		DoubleInput("amplitude-cutoff", amplitudeCutoff),
		DoubleInput("ringwidth", ringwidth),
		ImageOutput("out", &out),
	)
	err = vipsCall("mask_gaussian_ring", options)
	return out, err
}

// MaskIdeal executes the 'mask_ideal' operation.
func MaskIdeal(width int, height int, frequencyCutoff float64, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		IntInput("width", width),
		IntInput("height", height),
		DoubleInput("frequency-cutoff", frequencyCutoff),
		ImageOutput("out", &out),
	)
	err = vipsCall("mask_ideal", options)
	return out, err
}

// MaskIdealBand executes the 'mask_ideal_band' operation.
func MaskIdealBand(width int, height int, frequencyCutoffx float64, frequencyCutoffy float64, radius float64, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		IntInput("width", width),
		IntInput("height", height),
		DoubleInput("frequency-cutoff-x", frequencyCutoffx),
		DoubleInput("frequency-cutoff-y", frequencyCutoffy),
		DoubleInput("radius", radius),
		ImageOutput("out", &out),
	)
	err = vipsCall("mask_ideal_band", options)
	return out, err
}

// MaskIdealRing executes the 'mask_ideal_ring' operation.
func MaskIdealRing(width int, height int, frequencyCutoff float64, ringwidth float64, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		IntInput("width", width),
		IntInput("height", height),
		DoubleInput("frequency-cutoff", frequencyCutoff),
		DoubleInput("ringwidth", ringwidth),
		ImageOutput("out", &out),
	)
	err = vipsCall("mask_ideal_ring", options)
	return out, err
}

// Match executes the 'match' operation.
func Match(ref *C.VipsImage, sec *C.VipsImage, xr1 int, yr1 int, xs1 int, ys1 int, xr2 int, yr2 int, xs2 int, ys2 int, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(ref))
	defer C.g_object_unref(C.gpointer(sec))
	options := NewOptions(opts...).With(
		ImageInput("ref", ref),
		ImageInput("sec", sec),
		IntInput("xr1", xr1),
		IntInput("yr1", yr1),
		IntInput("xs1", xs1),
		IntInput("ys1", ys1),
		IntInput("xr2", xr2),
		IntInput("yr2", yr2),
		IntInput("xs2", xs2),
		IntInput("ys2", ys2),
		ImageOutput("out", &out),
	)
	err = vipsCall("match", options)
	return out, err
}

// Math executes the 'math' operation.
func Math(in *C.VipsImage, math OperationMath, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		IntInput("math", int(math)),
		ImageOutput("out", &out),
	)
	err = vipsCall("math", options)
	return out, err
}

func (os *OperationStream) Math(math OperationMath, opts ...OptionFunc) (*OperationStream, error) {
	out, err := Math(os.image, math, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Math2 executes the 'math2' operation.
func Math2(left *C.VipsImage, right *C.VipsImage, math2 OperationMath2, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(left))
	defer C.g_object_unref(C.gpointer(right))
	options := NewOptions(opts...).With(
		ImageInput("left", left),
		ImageInput("right", right),
		IntInput("math2", int(math2)),
		ImageOutput("out", &out),
	)
	err = vipsCall("math2", options)
	return out, err
}

// Matrixload executes the 'matrixload' operation.
func Matrixload(filename string, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		StringInput("filename", filename),
		ImageOutput("out", &out),
	)
	err = vipsCall("matrixload", options)
	return out, err
}

// Matrixprint executes the 'matrixprint' operation.
func Matrixprint(in *C.VipsImage, opts ...OptionFunc) error {
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
	)
	err = vipsCall("matrixprint", options)
	return err
}

// Matrixsave executes the 'matrixsave' operation.
func Matrixsave(in *C.VipsImage, filename string, opts ...OptionFunc) error {
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		StringInput("filename", filename),
	)
	err = vipsCall("matrixsave", options)
	return err
}

// Max executes the 'max' operation.
func Max(in *C.VipsImage, opts ...OptionFunc) (float64, error) {
	var out float64
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		DoubleOutput("out", &out),
	)
	err = vipsCall("max", options)
	return out, err
}

// Measure executes the 'measure' operation.
func Measure(in *C.VipsImage, h int, v int, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		IntInput("h", h),
		IntInput("v", v),
		ImageOutput("out", &out),
	)
	err = vipsCall("measure", options)
	return out, err
}

func (os *OperationStream) Measure(h int, v int, opts ...OptionFunc) (*OperationStream, error) {
	out, err := Measure(os.image, h, v, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Merge executes the 'merge' operation.
func Merge(ref *C.VipsImage, sec *C.VipsImage, direction Direction, dx int, dy int, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(ref))
	defer C.g_object_unref(C.gpointer(sec))
	options := NewOptions(opts...).With(
		ImageInput("ref", ref),
		ImageInput("sec", sec),
		IntInput("direction", int(direction)),
		IntInput("dx", dx),
		IntInput("dy", dy),
		ImageOutput("out", &out),
	)
	err = vipsCall("merge", options)
	return out, err
}

// Min executes the 'min' operation.
func Min(in *C.VipsImage, opts ...OptionFunc) (float64, error) {
	var out float64
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		DoubleOutput("out", &out),
	)
	err = vipsCall("min", options)
	return out, err
}

// Morph executes the 'morph' operation.
func Morph(in *C.VipsImage, mask *C.VipsImage, morph OperationMorphology, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	defer C.g_object_unref(C.gpointer(mask))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageInput("mask", mask),
		IntInput("morph", int(morph)),
		ImageOutput("out", &out),
	)
	err = vipsCall("morph", options)
	return out, err
}

// Mosaic executes the 'mosaic' operation.
func Mosaic(ref *C.VipsImage, sec *C.VipsImage, direction Direction, xref int, yref int, xsec int, ysec int, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(ref))
	defer C.g_object_unref(C.gpointer(sec))
	options := NewOptions(opts...).With(
		ImageInput("ref", ref),
		ImageInput("sec", sec),
		IntInput("direction", int(direction)),
		IntInput("xref", xref),
		IntInput("yref", yref),
		IntInput("xsec", xsec),
		IntInput("ysec", ysec),
		ImageOutput("out", &out),
	)
	err = vipsCall("mosaic", options)
	return out, err
}

// Mosaic1 executes the 'mosaic1' operation.
func Mosaic1(ref *C.VipsImage, sec *C.VipsImage, direction Direction, xr1 int, yr1 int, xs1 int, ys1 int, xr2 int, yr2 int, xs2 int, ys2 int, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(ref))
	defer C.g_object_unref(C.gpointer(sec))
	options := NewOptions(opts...).With(
		ImageInput("ref", ref),
		ImageInput("sec", sec),
		IntInput("direction", int(direction)),
		IntInput("xr1", xr1),
		IntInput("yr1", yr1),
		IntInput("xs1", xs1),
		IntInput("ys1", ys1),
		IntInput("xr2", xr2),
		IntInput("yr2", yr2),
		IntInput("xs2", xs2),
		IntInput("ys2", ys2),
		ImageOutput("out", &out),
	)
	err = vipsCall("mosaic1", options)
	return out, err
}

// Msb executes the 'msb' operation.
func Msb(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("msb", options)
	return out, err
}

func (os *OperationStream) Msb(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Msb(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Multiply executes the 'multiply' operation.
func Multiply(left *C.VipsImage, right *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(left))
	defer C.g_object_unref(C.gpointer(right))
	options := NewOptions(opts...).With(
		ImageInput("left", left),
		ImageInput("right", right),
		ImageOutput("out", &out),
	)
	err = vipsCall("multiply", options)
	return out, err
}

// Pdfload executes the 'pdfload' operation.
func Pdfload(filename string, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		StringInput("filename", filename),
		ImageOutput("out", &out),
	)
	err = vipsCall("pdfload", options)
	return out, err
}

// PdfloadBuffer executes the 'pdfload_buffer' operation.
func PdfloadBuffer(buffer *Blob, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		BlobInput("buffer", buffer),
		ImageOutput("out", &out),
	)
	err = vipsCall("pdfload_buffer", options)
	return out, err
}

// Percent executes the 'percent' operation.
func Percent(in *C.VipsImage, percent float64, opts ...OptionFunc) (int, error) {
	var threshold int
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		DoubleInput("percent", percent),
		IntOutput("threshold", &threshold),
	)
	err = vipsCall("percent", options)
	return threshold, err
}

// Perlin executes the 'perlin' operation.
func Perlin(width int, height int, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		IntInput("width", width),
		IntInput("height", height),
		ImageOutput("out", &out),
	)
	err = vipsCall("perlin", options)
	return out, err
}

// Phasecor executes the 'phasecor' operation.
func Phasecor(in *C.VipsImage, in2 *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	defer C.g_object_unref(C.gpointer(in2))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageInput("in2", in2),
		ImageOutput("out", &out),
	)
	err = vipsCall("phasecor", options)
	return out, err
}

// Pngload executes the 'pngload' operation.
func Pngload(filename string, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		StringInput("filename", filename),
		ImageOutput("out", &out),
	)
	err = vipsCall("pngload", options)
	return out, err
}

// PngloadBuffer executes the 'pngload_buffer' operation.
func PngloadBuffer(buffer *Blob, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		BlobInput("buffer", buffer),
		ImageOutput("out", &out),
	)
	err = vipsCall("pngload_buffer", options)
	return out, err
}

// Pngsave executes the 'pngsave' operation.
func Pngsave(in *C.VipsImage, filename string, opts ...OptionFunc) error {
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		StringInput("filename", filename),
	)
	err = vipsCall("pngsave", options)
	return err
}

// PngsaveBuffer executes the 'pngsave_buffer' operation.
func PngsaveBuffer(in *C.VipsImage, opts ...OptionFunc) (*Blob, error) {
	var buffer *Blob
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		BlobOutput("buffer", &buffer),
	)
	err = vipsCall("pngsave_buffer", options)
	return buffer, err
}

// Ppmload executes the 'ppmload' operation.
func Ppmload(filename string, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		StringInput("filename", filename),
		ImageOutput("out", &out),
	)
	err = vipsCall("ppmload", options)
	return out, err
}

// Ppmsave executes the 'ppmsave' operation.
func Ppmsave(in *C.VipsImage, filename string, opts ...OptionFunc) error {
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		StringInput("filename", filename),
	)
	err = vipsCall("ppmsave", options)
	return err
}

// Premultiply executes the 'premultiply' operation.
func Premultiply(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("premultiply", options)
	return out, err
}

func (os *OperationStream) Premultiply(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Premultiply(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Profile executes the 'profile' operation.
func Profile(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, *C.VipsImage, error) {
	var columns *C.VipsImage
	var rows *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("columns", &columns),
		ImageOutput("rows", &rows),
	)
	err = vipsCall("profile", options)
	return columns, rows, err
}

// Project executes the 'project' operation.
func Project(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, *C.VipsImage, error) {
	var columns *C.VipsImage
	var rows *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("columns", &columns),
		ImageOutput("rows", &rows),
	)
	err = vipsCall("project", options)
	return columns, rows, err
}

// Quadratic executes the 'quadratic' operation.
func Quadratic(in *C.VipsImage, coeff *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	defer C.g_object_unref(C.gpointer(coeff))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageInput("coeff", coeff),
		ImageOutput("out", &out),
	)
	err = vipsCall("quadratic", options)
	return out, err
}

// Rad2Float executes the 'rad2float' operation.
func Rad2Float(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("rad2float", options)
	return out, err
}

func (os *OperationStream) Rad2Float(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Rad2Float(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Radload executes the 'radload' operation.
func Radload(filename string, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		StringInput("filename", filename),
		ImageOutput("out", &out),
	)
	err = vipsCall("radload", options)
	return out, err
}

// Radsave executes the 'radsave' operation.
func Radsave(in *C.VipsImage, filename string, opts ...OptionFunc) error {
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		StringInput("filename", filename),
	)
	err = vipsCall("radsave", options)
	return err
}

// RadsaveBuffer executes the 'radsave_buffer' operation.
func RadsaveBuffer(in *C.VipsImage, opts ...OptionFunc) (*Blob, error) {
	var buffer *Blob
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		BlobOutput("buffer", &buffer),
	)
	err = vipsCall("radsave_buffer", options)
	return buffer, err
}

// Rank executes the 'rank' operation.
func Rank(in *C.VipsImage, width int, height int, index int, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		IntInput("width", width),
		IntInput("height", height),
		IntInput("index", index),
		ImageOutput("out", &out),
	)
	err = vipsCall("rank", options)
	return out, err
}

func (os *OperationStream) Rank(width int, height int, index int, opts ...OptionFunc) (*OperationStream, error) {
	out, err := Rank(os.image, width, height, index, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Rawload executes the 'rawload' operation.
func Rawload(filename string, width int, height int, bands int, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		StringInput("filename", filename),
		IntInput("width", width),
		IntInput("height", height),
		IntInput("bands", bands),
		ImageOutput("out", &out),
	)
	err = vipsCall("rawload", options)
	return out, err
}

// Rawsave executes the 'rawsave' operation.
func Rawsave(in *C.VipsImage, filename string, opts ...OptionFunc) error {
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		StringInput("filename", filename),
	)
	err = vipsCall("rawsave", options)
	return err
}

// RawsaveFd executes the 'rawsave_fd' operation.
func RawsaveFd(in *C.VipsImage, fd int, opts ...OptionFunc) error {
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		IntInput("fd", fd),
	)
	err = vipsCall("rawsave_fd", options)
	return err
}

// Recomb executes the 'recomb' operation.
func Recomb(in *C.VipsImage, m *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	defer C.g_object_unref(C.gpointer(m))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageInput("m", m),
		ImageOutput("out", &out),
	)
	err = vipsCall("recomb", options)
	return out, err
}

// Reduce executes the 'reduce' operation.
func Reduce(in *C.VipsImage, hshrink float64, vshrink float64, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		DoubleInput("hshrink", hshrink),
		DoubleInput("vshrink", vshrink),
		ImageOutput("out", &out),
	)
	err = vipsCall("reduce", options)
	return out, err
}

func (os *OperationStream) Reduce(hshrink float64, vshrink float64, opts ...OptionFunc) (*OperationStream, error) {
	out, err := Reduce(os.image, hshrink, vshrink, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Reduceh executes the 'reduceh' operation.
func Reduceh(in *C.VipsImage, hshrink float64, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		DoubleInput("hshrink", hshrink),
		ImageOutput("out", &out),
	)
	err = vipsCall("reduceh", options)
	return out, err
}

func (os *OperationStream) Reduceh(hshrink float64, opts ...OptionFunc) (*OperationStream, error) {
	out, err := Reduceh(os.image, hshrink, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Reducev executes the 'reducev' operation.
func Reducev(in *C.VipsImage, vshrink float64, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		DoubleInput("vshrink", vshrink),
		ImageOutput("out", &out),
	)
	err = vipsCall("reducev", options)
	return out, err
}

func (os *OperationStream) Reducev(vshrink float64, opts ...OptionFunc) (*OperationStream, error) {
	out, err := Reducev(os.image, vshrink, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Relational executes the 'relational' operation.
func Relational(left *C.VipsImage, right *C.VipsImage, relational OperationRelational, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(left))
	defer C.g_object_unref(C.gpointer(right))
	options := NewOptions(opts...).With(
		ImageInput("left", left),
		ImageInput("right", right),
		IntInput("relational", int(relational)),
		ImageOutput("out", &out),
	)
	err = vipsCall("relational", options)
	return out, err
}

// Remainder executes the 'remainder' operation.
func Remainder(left *C.VipsImage, right *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(left))
	defer C.g_object_unref(C.gpointer(right))
	options := NewOptions(opts...).With(
		ImageInput("left", left),
		ImageInput("right", right),
		ImageOutput("out", &out),
	)
	err = vipsCall("remainder", options)
	return out, err
}

// Replicate executes the 'replicate' operation.
func Replicate(in *C.VipsImage, across int, down int, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		IntInput("across", across),
		IntInput("down", down),
		ImageOutput("out", &out),
	)
	err = vipsCall("replicate", options)
	return out, err
}

func (os *OperationStream) Replicate(across int, down int, opts ...OptionFunc) (*OperationStream, error) {
	out, err := Replicate(os.image, across, down, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Resize executes the 'resize' operation.
func Resize(in *C.VipsImage, scale float64, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		DoubleInput("scale", scale),
		ImageOutput("out", &out),
	)
	err = vipsCall("resize", options)
	return out, err
}

func (os *OperationStream) Resize(scale float64, opts ...OptionFunc) (*OperationStream, error) {
	out, err := Resize(os.image, scale, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Rot executes the 'rot' operation.
func Rot(in *C.VipsImage, angle Angle, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		IntInput("angle", int(angle)),
		ImageOutput("out", &out),
	)
	err = vipsCall("rot", options)
	return out, err
}

func (os *OperationStream) Rot(angle Angle, opts ...OptionFunc) (*OperationStream, error) {
	out, err := Rot(os.image, angle, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Rot45 executes the 'rot45' operation.
func Rot45(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("rot45", options)
	return out, err
}

func (os *OperationStream) Rot45(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Rot45(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Round executes the 'round' operation.
func Round(in *C.VipsImage, round OperationRound, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		IntInput("round", int(round)),
		ImageOutput("out", &out),
	)
	err = vipsCall("round", options)
	return out, err
}

func (os *OperationStream) Round(round OperationRound, opts ...OptionFunc) (*OperationStream, error) {
	out, err := Round(os.image, round, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Scale executes the 'scale' operation.
func Scale(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("scale", options)
	return out, err
}

func (os *OperationStream) Scale(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Scale(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Scrgb2Bw executes the 'scRGB2BW' operation.
func Scrgb2Bw(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("scRGB2BW", options)
	return out, err
}

func (os *OperationStream) Scrgb2Bw(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Scrgb2Bw(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Scrgb2Srgb executes the 'scRGB2sRGB' operation.
func Scrgb2Srgb(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("scRGB2sRGB", options)
	return out, err
}

func (os *OperationStream) Scrgb2Srgb(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Scrgb2Srgb(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Scrgb2Xyz executes the 'scRGB2XYZ' operation.
func Scrgb2Xyz(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("scRGB2XYZ", options)
	return out, err
}

func (os *OperationStream) Scrgb2Xyz(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Scrgb2Xyz(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Sequential executes the 'sequential' operation.
func Sequential(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("sequential", options)
	return out, err
}

func (os *OperationStream) Sequential(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Sequential(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Sharpen executes the 'sharpen' operation.
func Sharpen(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("sharpen", options)
	return out, err
}

func (os *OperationStream) Sharpen(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Sharpen(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Shrink executes the 'shrink' operation.
func Shrink(in *C.VipsImage, hshrink float64, vshrink float64, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		DoubleInput("hshrink", hshrink),
		DoubleInput("vshrink", vshrink),
		ImageOutput("out", &out),
	)
	err = vipsCall("shrink", options)
	return out, err
}

func (os *OperationStream) Shrink(hshrink float64, vshrink float64, opts ...OptionFunc) (*OperationStream, error) {
	out, err := Shrink(os.image, hshrink, vshrink, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Shrinkh executes the 'shrinkh' operation.
func Shrinkh(in *C.VipsImage, hshrink int, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		IntInput("hshrink", hshrink),
		ImageOutput("out", &out),
	)
	err = vipsCall("shrinkh", options)
	return out, err
}

func (os *OperationStream) Shrinkh(hshrink int, opts ...OptionFunc) (*OperationStream, error) {
	out, err := Shrinkh(os.image, hshrink, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Shrinkv executes the 'shrinkv' operation.
func Shrinkv(in *C.VipsImage, vshrink int, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		IntInput("vshrink", vshrink),
		ImageOutput("out", &out),
	)
	err = vipsCall("shrinkv", options)
	return out, err
}

func (os *OperationStream) Shrinkv(vshrink int, opts ...OptionFunc) (*OperationStream, error) {
	out, err := Shrinkv(os.image, vshrink, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Sign executes the 'sign' operation.
func Sign(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("sign", options)
	return out, err
}

func (os *OperationStream) Sign(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Sign(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Similarity executes the 'similarity' operation.
func Similarity(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("similarity", options)
	return out, err
}

func (os *OperationStream) Similarity(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Similarity(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Sines executes the 'sines' operation.
func Sines(width int, height int, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		IntInput("width", width),
		IntInput("height", height),
		ImageOutput("out", &out),
	)
	err = vipsCall("sines", options)
	return out, err
}

// Smartcrop executes the 'smartcrop' operation.
func Smartcrop(input *C.VipsImage, width int, height int, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(input))
	options := NewOptions(opts...).With(
		ImageInput("input", input),
		IntInput("width", width),
		IntInput("height", height),
		ImageOutput("out", &out),
	)
	err = vipsCall("smartcrop", options)
	return out, err
}

func (os *OperationStream) Smartcrop(width int, height int, opts ...OptionFunc) (*OperationStream, error) {
	out, err := Smartcrop(os.image, width, height, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Spcor executes the 'spcor' operation.
func Spcor(in *C.VipsImage, ref *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	defer C.g_object_unref(C.gpointer(ref))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageInput("ref", ref),
		ImageOutput("out", &out),
	)
	err = vipsCall("spcor", options)
	return out, err
}

// Spectrum executes the 'spectrum' operation.
func Spectrum(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("spectrum", options)
	return out, err
}

func (os *OperationStream) Spectrum(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Spectrum(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Srgb2Hsv executes the 'sRGB2HSV' operation.
func Srgb2Hsv(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("sRGB2HSV", options)
	return out, err
}

func (os *OperationStream) Srgb2Hsv(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Srgb2Hsv(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Srgb2Scrgb executes the 'sRGB2scRGB' operation.
func Srgb2Scrgb(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("sRGB2scRGB", options)
	return out, err
}

func (os *OperationStream) Srgb2Scrgb(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Srgb2Scrgb(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Stats executes the 'stats' operation.
func Stats(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("stats", options)
	return out, err
}

func (os *OperationStream) Stats(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Stats(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Stdif executes the 'stdif' operation.
func Stdif(in *C.VipsImage, width int, height int, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		IntInput("width", width),
		IntInput("height", height),
		ImageOutput("out", &out),
	)
	err = vipsCall("stdif", options)
	return out, err
}

func (os *OperationStream) Stdif(width int, height int, opts ...OptionFunc) (*OperationStream, error) {
	out, err := Stdif(os.image, width, height, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Subsample executes the 'subsample' operation.
func Subsample(input *C.VipsImage, xfac int, yfac int, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(input))
	options := NewOptions(opts...).With(
		ImageInput("input", input),
		IntInput("xfac", xfac),
		IntInput("yfac", yfac),
		ImageOutput("out", &out),
	)
	err = vipsCall("subsample", options)
	return out, err
}

func (os *OperationStream) Subsample(xfac int, yfac int, opts ...OptionFunc) (*OperationStream, error) {
	out, err := Subsample(os.image, xfac, yfac, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Subtract executes the 'subtract' operation.
func Subtract(left *C.VipsImage, right *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(left))
	defer C.g_object_unref(C.gpointer(right))
	options := NewOptions(opts...).With(
		ImageInput("left", left),
		ImageInput("right", right),
		ImageOutput("out", &out),
	)
	err = vipsCall("subtract", options)
	return out, err
}

// Svgload executes the 'svgload' operation.
func Svgload(filename string, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		StringInput("filename", filename),
		ImageOutput("out", &out),
	)
	err = vipsCall("svgload", options)
	return out, err
}

// SvgloadBuffer executes the 'svgload_buffer' operation.
func SvgloadBuffer(buffer *Blob, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		BlobInput("buffer", buffer),
		ImageOutput("out", &out),
	)
	err = vipsCall("svgload_buffer", options)
	return out, err
}

// System executes the 'system' operation.
func System(cmdFormat string, opts ...OptionFunc) error {
	var err error

	options := NewOptions(opts...).With(
		StringInput("cmd-format", cmdFormat),
	)
	err = vipsCall("system", options)
	return err
}

// Text executes the 'text' operation.
func Text(text string, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		StringInput("text", text),
		ImageOutput("out", &out),
	)
	err = vipsCall("text", options)
	return out, err
}

// Thumbnail executes the 'thumbnail' operation.
func Thumbnail(filename string, width int, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		StringInput("filename", filename),
		IntInput("width", width),
		ImageOutput("out", &out),
	)
	err = vipsCall("thumbnail", options)
	return out, err
}

// ThumbnailBuffer executes the 'thumbnail_buffer' operation.
func ThumbnailBuffer(buffer *Blob, width int, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		BlobInput("buffer", buffer),
		IntInput("width", width),
		ImageOutput("out", &out),
	)
	err = vipsCall("thumbnail_buffer", options)
	return out, err
}

// Tiffload executes the 'tiffload' operation.
func Tiffload(filename string, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		StringInput("filename", filename),
		ImageOutput("out", &out),
	)
	err = vipsCall("tiffload", options)
	return out, err
}

// TiffloadBuffer executes the 'tiffload_buffer' operation.
func TiffloadBuffer(buffer *Blob, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		BlobInput("buffer", buffer),
		ImageOutput("out", &out),
	)
	err = vipsCall("tiffload_buffer", options)
	return out, err
}

// Tiffsave executes the 'tiffsave' operation.
func Tiffsave(in *C.VipsImage, filename string, opts ...OptionFunc) error {
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		StringInput("filename", filename),
	)
	err = vipsCall("tiffsave", options)
	return err
}

// TiffsaveBuffer executes the 'tiffsave_buffer' operation.
func TiffsaveBuffer(in *C.VipsImage, opts ...OptionFunc) (*Blob, error) {
	var buffer *Blob
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		BlobOutput("buffer", &buffer),
	)
	err = vipsCall("tiffsave_buffer", options)
	return buffer, err
}

// Tilecache executes the 'tilecache' operation.
func Tilecache(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("tilecache", options)
	return out, err
}

func (os *OperationStream) Tilecache(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Tilecache(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Tonelut executes the 'tonelut' operation.
func Tonelut(opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(

		ImageOutput("out", &out),
	)
	err = vipsCall("tonelut", options)
	return out, err
}

// Unpremultiply executes the 'unpremultiply' operation.
func Unpremultiply(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("unpremultiply", options)
	return out, err
}

func (os *OperationStream) Unpremultiply(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Unpremultiply(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Vipsload executes the 'vipsload' operation.
func Vipsload(filename string, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		StringInput("filename", filename),
		ImageOutput("out", &out),
	)
	err = vipsCall("vipsload", options)
	return out, err
}

// Vipssave executes the 'vipssave' operation.
func Vipssave(in *C.VipsImage, filename string, opts ...OptionFunc) error {
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		StringInput("filename", filename),
	)
	err = vipsCall("vipssave", options)
	return err
}

// Webpload executes the 'webpload' operation.
func Webpload(filename string, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		StringInput("filename", filename),
		ImageOutput("out", &out),
	)
	err = vipsCall("webpload", options)
	return out, err
}

// WebploadBuffer executes the 'webpload_buffer' operation.
func WebploadBuffer(buffer *Blob, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		BlobInput("buffer", buffer),
		ImageOutput("out", &out),
	)
	err = vipsCall("webpload_buffer", options)
	return out, err
}

// Webpsave executes the 'webpsave' operation.
func Webpsave(in *C.VipsImage, filename string, opts ...OptionFunc) error {
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		StringInput("filename", filename),
	)
	err = vipsCall("webpsave", options)
	return err
}

// WebpsaveBuffer executes the 'webpsave_buffer' operation.
func WebpsaveBuffer(in *C.VipsImage, opts ...OptionFunc) (*Blob, error) {
	var buffer *Blob
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		BlobOutput("buffer", &buffer),
	)
	err = vipsCall("webpsave_buffer", options)
	return buffer, err
}

// Worley executes the 'worley' operation.
func Worley(width int, height int, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		IntInput("width", width),
		IntInput("height", height),
		ImageOutput("out", &out),
	)
	err = vipsCall("worley", options)
	return out, err
}

// Wrap executes the 'wrap' operation.
func Wrap(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("wrap", options)
	return out, err
}

func (os *OperationStream) Wrap(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Wrap(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Xyz executes the 'xyz' operation.
func Xyz(width int, height int, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		IntInput("width", width),
		IntInput("height", height),
		ImageOutput("out", &out),
	)
	err = vipsCall("xyz", options)
	return out, err
}

// Xyz2Lab executes the 'XYZ2Lab' operation.
func Xyz2Lab(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("XYZ2Lab", options)
	return out, err
}

func (os *OperationStream) Xyz2Lab(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Xyz2Lab(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Xyz2Scrgb executes the 'XYZ2scRGB' operation.
func Xyz2Scrgb(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("XYZ2scRGB", options)
	return out, err
}

func (os *OperationStream) Xyz2Scrgb(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Xyz2Scrgb(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Xyz2Yxy executes the 'XYZ2Yxy' operation.
func Xyz2Yxy(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("XYZ2Yxy", options)
	return out, err
}

func (os *OperationStream) Xyz2Yxy(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Xyz2Yxy(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Yxy2Xyz executes the 'Yxy2XYZ' operation.
func Yxy2Xyz(in *C.VipsImage, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(in))
	options := NewOptions(opts...).With(
		ImageInput("in", in),
		ImageOutput("out", &out),
	)
	err = vipsCall("Yxy2XYZ", options)
	return out, err
}

func (os *OperationStream) Yxy2Xyz(opts ...OptionFunc) (*OperationStream, error) {
	out, err := Yxy2Xyz(os.image, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}

// Zone executes the 'zone' operation.
func Zone(width int, height int, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error

	options := NewOptions(opts...).With(
		IntInput("width", width),
		IntInput("height", height),
		ImageOutput("out", &out),
	)
	err = vipsCall("zone", options)
	return out, err
}

// Zoom executes the 'zoom' operation.
func Zoom(input *C.VipsImage, xfac int, yfac int, opts ...OptionFunc) (*C.VipsImage, error) {
	var out *C.VipsImage
	var err error
	defer C.g_object_unref(C.gpointer(input))
	options := NewOptions(opts...).With(
		ImageInput("input", input),
		IntInput("xfac", xfac),
		IntInput("yfac", yfac),
		ImageOutput("out", &out),
	)
	err = vipsCall("zoom", options)
	return out, err
}

func (os *OperationStream) Zoom(xfac int, yfac int, opts ...OptionFunc) (*OperationStream, error) {
	out, err := Zoom(os.image, xfac, yfac, opts...)
	if err != nil {
		return os, err
	}
	os.image = out
	return os, nil
}
